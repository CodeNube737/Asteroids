what is a good way to create a new file called CAsteroidsGame(.h .cpp) that runs the following functions instead of from CShip.h:
 - run()
 - update()
 - draw(....)
 - userInput(.....)
 - move(...............)

See below the aforementioned .h and .cpp files:

// CShip.h
#pragma once
#include <opencv2/opencv.hpp>

#define WINDOW_WIDTH 800
#define WINDOW_HEIGHT 600
#define max_velocity 10
#define DELAY 30

class Spaceship
{
private:
    bool leave;
    char key;
    cv::Point position;
    cv::Point velocity;
    cv::Mat img;

public:
    Spaceship(cv::Point position);

    //gets & sets
    cv::Point getPosition() {return position;}
    void setPosition(cv::Point newPosition) {position = newPosition;}

    //methods
    void run();
    void update();
    void draw(cv::Mat& img);
    void userInput(char direction);
    void move(int window_width, int window_height);
};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


//CShip.cpp
#include "CShip.h"

Spaceship::Spaceship(cv::Point position) :
    leave(false), key('0'), position(position), velocity(cv::Point(0, 0))
{
    img = cv::Mat(WINDOW_HEIGHT, WINDOW_WIDTH, CV_8UC3, cv::Scalar(0, 0, 0));
}

void Spaceship::run()
{
    while (!leave)
    {
        update();
        draw(img);
    }
}

void Spaceship::update()
{
    key = cv::waitKey(DELAY);
    userInput(key);
    move(WINDOW_WIDTH, WINDOW_HEIGHT);
}

void Spaceship::draw(cv::Mat& img)
{
    img = cv::Scalar::all(0);
    cv::circle(img, position, 10, cv::Scalar(0, 165, 255), -1);
    cv::putText(img, "Press 'l' to leave", cv::Point(WINDOW_WIDTH/2 - 135, WINDOW_HEIGHT/2 - 25), cv::FONT_HERSHEY_SIMPLEX, 1, cv::Scalar(255, 255, 255), 2);
    cv::imshow("Spaceship", img);
}

void Spaceship::userInput(char direction)
{
    int acceleration = 1;
    switch (direction)
    {
    case 'w': velocity.y -= acceleration; break;
    case 's': velocity.y += acceleration; break;
    case 'a': velocity.x -= acceleration; break;
    case 'd': velocity.x += acceleration; break;
    case 'l': leave = true; break;
    }

    // Limit velocity to max_velocity
    velocity.x = std::min(std::max(velocity.x, -max_velocity), max_velocity);
    velocity.y = std::min(std::max(velocity.y, -max_velocity), max_velocity);
}

void Spaceship::move(int window_width, int window_height)
{
    position += velocity;

    // Wrap around if the spaceship goes off-screen
    if (position.x < 0) position.x = window_width;
    if (position.x > window_width) position.x = 0;
    if (position.y < 0) position.y = window_height;
    if (position.y > window_height) position.y = 0;
}



